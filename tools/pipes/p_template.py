import this
from argparse import Namespace
import logging
from threading import Thread, Event
from abc import ABC, abstractmethod
from typing import Set

from utilities.custom_structs import PopList


class BundleDictionary(ABC):
    """
    Abstract class for shared states
    """

    @staticmethod
    def fid(p: property):
        return id(p)


class SAd(BundleDictionary):
    """
    StreetAnalytics context state (for state sharing in thread concurrences)
    Class containing all keys used by routines to update and access state values
    Use Property id for adding/extracting state values : e.g. id(SA_d.MxCloudLs)

    Note: PYCharm might indicate that property can't be read - ignore this warning
    """

    LiveListSensor: PopList = property(doc="Queue generated by ouster_sensor class for frame collection")
    MxCloudLs: PopList = property(doc='PcapList loaded from PcapPath')
    PcapPath: str = property(doc='Provided relative path to pcap file')
    NpyArrLs: PopList = property(doc='Numpy ndarray list')
    MatrixCloudLs: PopList = property(doc='MatrixCloudsList')
    ModelName: str = property(doc="")
    ProcessedList: PopList = property(doc="MatrixCloud conversion to ML model dataset input format")
    Statistics: PopList = property(doc="Statistic module output for all frames, updated during data processing."
                                       " Refer to module for dict documentation")
    Success: bool = property(doc='Pipeline step state True if completed without exceptions')
    Step: str = property(doc="current pipeline step")
    Host: str = property(doc='hostname')
    Port: int = property(doc='port')


GN = SAd


class State:
    """
    Wrapper class for state and args used in script execution
    """
    state: dict
    args: Namespace

    def __init__(self, args: Namespace = None):
        self.state = {
            id(GN.Success): True
        }
        self.args = args

    def merge(self, new_state):
        self.state.update(new_state.state)

    def __setitem__(self, key, value):
        self.state[key] = value

    def __getitem__(self, key):
        print(str(key))
        return self.state[key]


class RoutineSet:
    import logging
    logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.INFO)
    log = logging

class Pipeline(ABC, Thread):
    """
    state
    produce: data resources
    consume: data resources
    in_opt: in options from args
    out_opt: out options from args

    """
    state: State
    produce: Set[property]
    consume: Set[property]
    in_options: Set[str]
    out_options: Set[str]

    def __init__(self, prev: State = None, threaded: bool = True):
        super().__init__()
        self.state = prev if prev is not None else State()
        self.threaded = threaded
        self.event = Event()
        self.produce = set()
        self.consume = set()

    @abstractmethod
    def run(self, *args):
        """
        Abstract function to check current state and update step location

        Parameters
        ----------
        Returns
        -------

        """
        if not self.state[id(GN.Success)]:
            logging.Logger.error(f'Broken pipe at step f{self.state["step"]}')
            exit(1)
        self.state[id(GN.Step)] = self.__class__.__name__

    def flow(self):
        """
        Wrapper function for launching routine either on a new thread or
        in current thread (blocking function)"""
        if self.threaded:
            self.start()
        else:
            self.run()
