import logging
from threading import Thread, Event
from abc import ABC, abstractmethod


class GlobalDictionary:
    """
    Class containing all keys used by pipes to update and access state values
    Use this class to update own pipe state before calling super().update()
    Note: PYCharm might indicate that property can't be read - ignore this warning
    """
    LiveQueueSensor = property(fget=None, doc="Queue generated by ouster_sensor class for frame collection")
    PcapList = property(doc='')
    MatrixCloud = property(doc='')
    ModelName = property(doc="")
    ProcessedQueue = property(doc="MatrixCloud conversion to ML model dataset input format")
    Statistics = property(doc="Statistic module output for all frames, updated during data processing."
                              " Refer to module for dict documentation")
    Success = property(doc='Pipeline step state True if completed without exceptions')
    Step = property(doc="current pipeline step")
    Host = property(doc='hostname')
    Port = property(doc='port')


GN = GlobalDictionary


class State:
    """
    Wrapper class for state and args used in script execution
    """
    state: dict
    args: dict

    def __init__(self):
        self.state = {
            GN.Success: True
        }

    def merge(self, new_state):
        self.state.update(new_state.state)

    def __setitem__(self, key, value):
        self.state[key] = value

    def __getitem__(self, key):
        print(str(key))
        return self.state[key]


class Pipeline(ABC, Thread):
    state: State = State()

    def __init__(self, prev: state, threaded: bool = True):
        super().__init__()
        self.state = prev
        self.threaded = threaded
        self.event = Event()

    @abstractmethod
    def run(self, *args):
        """
        Abstract function to check current state and update step location

        Parameters
        ----------
        Returns
        -------

        """
        if not self.state[GN.Success]:
            logging.Logger.error(f'Broken pipe at step f{self.state["step"]}')
            exit(1)
        self.state[GN.Step] = self.__class__.__name__

    def flow(self):
        if self.threaded:
            self.start()
        else:
            self.run()
